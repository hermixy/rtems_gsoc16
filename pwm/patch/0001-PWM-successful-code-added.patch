From 9a46c91944a49d19137915b46362e5cf1bcfcf9b Mon Sep 17 00:00:00 2001
From: Punit Vara <punitvara@gmail.com>
Date: Sat, 16 Apr 2016 00:13:27 +0530
Subject: [PATCH 3/3] PWM successful code added

---
 c/src/lib/libbsp/arm/beagle/include/bbb-pwm.h |  10 +-
 c/src/lib/libbsp/arm/beagle/pwm/bbb-pwm.c     | 260 +++++++++++++++++++++++++-
 c/src/lib/libbsp/shared/include/gpio.h        |  51 +++++
 c/src/lib/libcpu/arm/shared/include/am335x.h  |   5 +-
 testsuites/samples/Makefile.am                |   2 +-
 testsuites/samples/configure.ac               |   1 +
 testsuites/samples/pwm/Makefile.am            |  19 ++
 testsuites/samples/pwm/init.c                 |  77 ++++++++
 testsuites/samples/pwm/pwm.doc                |   9 +
 testsuites/samples/pwm/pwm.scn                |   3 +
 14 files changed, 430 insertions(+), 7 deletions(-)
 create mode 100644 testsuites/samples/pwm/Makefile.am
 create mode 100644 testsuites/samples/pwm/init.c
 create mode 100644 testsuites/samples/pwm/pwm.doc
 create mode 100644 testsuites/samples/pwm/pwm.scn

diff --git a/c/src/lib/libbsp/arm/beagle/include/bbb-pwm.h b/c/src/lib/libbsp/arm/beagle/include/bbb-pwm.h
index c5f76e5..5102f33 100644
--- a/c/src/lib/libbsp/arm/beagle/include/bbb-pwm.h
+++ b/c/src/lib/libbsp/arm/beagle/include/bbb-pwm.h
@@ -1,8 +1,8 @@
 #ifndef LIBBSP_ARM_BEAGLE_BBB_PWM_H
 #define LIBBSP_ARM_BEAGLE_BBB_PWM_H
 
-
 void PWMSSTBClkEnable(unsigned int instance);
+void EHRPWMClockEnable(unsigned int baseAdd);
 void PWMSSModuleClkConfig(unsigned int instanceNum);
 void EHRPWMTimebaseClkConfig(unsigned int baseAddr,
                              unsigned int tbClk,
@@ -33,6 +33,14 @@ void EHRPWMConfigureAQActionOnB(unsigned int baseAddr,
                                 unsigned int CBUp,
                                 unsigned int CBDown,
                                 unsigned int SWForced);
+void EHRPWMConfigureAQActionOnA(unsigned int baseAddr,
+                                unsigned int zero,
+                                unsigned int period,
+                                unsigned int CAUp,
+                                unsigned int CADown,
+                                unsigned int CBUp,
+                                unsigned int CBDown,
+                                unsigned int SWForced);
 void EHRPWMDBOutput(unsigned int baseAddr, unsigned int DBgenOpMode);
 void EHRPWMChopperDisable(unsigned int baseAddr);
 void EHRPWMTZTripEventDisable(unsigned int baseAddr, bool osht_CBC);
diff --git a/c/src/lib/libbsp/arm/beagle/pwm/bbb-pwm.c b/c/src/lib/libbsp/arm/beagle/pwm/bbb-pwm.c
index c5c69db..4b427bb 100644
--- a/c/src/lib/libbsp/arm/beagle/pwm/bbb-pwm.c
+++ b/c/src/lib/libbsp/arm/beagle/pwm/bbb-pwm.c
@@ -1,3 +1,44 @@
+/**
+ *  \file   bbb-pwm.c
+ *
+ *  \brief  This file contains the device abstraction layer APIs for EHRPWM.
+ */
+
+/*
+* Copyright (C) 2010 Texas Instruments Incorporated - http://www.ti.com/
+*/
+/*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*    Redistributions of source code must retain the above copyright
+*    notice, this list of conditions and the following disclaimer.
+*
+*    Redistributions in binary form must reproduce the above copyright
+*    notice, this list of conditions and the following disclaimer in the
+*    documentation and/or other materials provided with the
+*    distribution.
+*
+*    Neither the name of Texas Instruments Incorporated nor the names of
+*    its contributors may be used to endorse or promote products derived
+*    from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*   
+*/
+
+
 #include<libcpu/am335x.h>
 #include<stdio.h>
 #include<bsp/gpio.h>
@@ -17,17 +58,17 @@ void PWMSSTBClkEnable(unsigned int instance)
     {
 
          case 0:
-               REG(SOC_CONTROL_REGS + CONTROL_PWMSS_CTRL) |=
+               REG(AM335X_PADCONF_BASE + CONTROL_PWMSS_CTRL) |=
                                              CONTROL_PWMSS_CTRL_PWMSS0_TBCLKEN;
                break;
 
          case 1:
-               REG(SOC_CONTROL_REGS + CONTROL_PWMSS_CTRL) |=
+               REG(AM335X_PADCONF_BASE + CONTROL_PWMSS_CTRL) |=
                                              CONTROL_PWMSS_CTRL_PWMMS1_TBCLKEN;
                break;
 
          case 2:
-               REG(SOC_CONTROL_REGS + CONTROL_PWMSS_CTRL) |=
+               REG(AM335X_PADCONF_BASE + CONTROL_PWMSS_CTRL) |=
                                              CONTROL_PWMSS_CTRL_PWMSS2_TBCLKEN;
                break;
 
@@ -36,6 +77,51 @@ void PWMSSTBClkEnable(unsigned int instance)
     }
 }
 
+void EPWMPinMuxSetup(void)
+{
+REG(AM335X_PADCONF_BASE + CONTROL_CONF_GPMC_AD(9)) = BBB_MUXMODE(4);
+
+REG(AM335X_PADCONF_BASE + CONTROL_CONF_GPMC_AD(8)) = BBB_MUXMODE(4);
+
+REG(AM335X_PADCONF_BASE + CONTROL_CONF_LCD_DATA(0)) = BBB_MUXMODE(3);
+
+REG(AM335X_PADCONF_BASE + CONTROL_CONF_LCD_DATA(1)) = BBB_MUXMODE(3);
+
+REG(AM335X_PADCONF_BASE + CONTROL_CONF_LCD_DATA(11)) = BBB_MUXMODE(2);
+
+REG(AM335X_PADCONF_BASE + CONTROL_CONF_LCD_DATA(10)) = BBB_MUXMODE(2);
+
+REG(AM335X_PADCONF_BASE + CONTROL_CONF_GPMC_AD(2)) = BBB_MUXMODE(6);
+
+REG(AM335X_PADCONF_BASE + CONTROL_CONF_GPMC_AD(3)) = BBB_MUXMODE(6);
+
+REG(AM335X_PADCONF_BASE + AM335X_CONF_SPI0_D0) = BBB_MUXMODE(3);
+
+REG(AM335X_PADCONF_BASE + AM335X_CONF_SPI0_SCLK) = BBB_MUXMODE(3);
+
+REG(AM335X_PADCONF_BASE + AM335X_CONF_MCASP0_FSX) = BBB_MUXMODE(1);
+
+REG(AM335X_PADCONF_BASE + AM335X_CONF_MCASP0_ACLKX) = BBB_MUXMODE(1);
+}
+
+
+
+
+/**
+ * \brief   This functions enables clock for EHRPWM module in PWMSS subsystem.
+ *
+ * \param   baseAdd   It is the Memory address of the PWMSS instance used.
+ *
+ * \return  None.
+ *
+ **/
+
+void EHRPWMClockEnable(unsigned int baseAdd)
+{
+    REG(baseAdd + PWMSS_CLOCK_CONFIG) |= PWMSS_EHRPWM_CLK_EN_ACK;
+}
+
+
 /**
  * \brief   This function configures the L3 and L4_PER system clocks.
  *          It also configures the system clocks for the specified ePWMSS
@@ -423,6 +509,52 @@ void EHRPWMConfigureAQActionOnB(unsigned int baseAddr,
      ((SWForced << EHRPWM_AQSFRC_ACTSFB_SHIFT) & EHRPWM_AQSFRC_ACTSFB);
 }
 /**
+ * \brief  This API configures the action to be taken on A by the Action
+ *         qualifier module upon receiving the events. This will determine
+ *         the output waveform.
+ *
+ * \param   zero      Action to be taken when CTR = 0
+ * \param   period    Action to be taken when CTR = PRD
+ * \param   CAUp      Action to be taken when CTR = CAUp
+ * \param   CADown    Action to be taken when CTR = CADown
+ * \param   CBUp      Action to be taken when CTR = CBUp
+ * \param   CBDown    Action to be taken when CTR = CBDown
+ * \param   SWForced  Action to be taken when SW forced event has been generated
+ *
+ *     Possible values for the actions are
+ *          - EHRPWM_XXXX_XXXX_DONOTHING \n
+ *          - EHRPWM_XXXX_XXXX_CLEAR \n
+ *          - EHRPWM_XXXX_XXXX_SET \n
+ *          - EHRPWM_XXXX_XXXX_TOGGLE \n
+ *
+ * \return  None
+ *
+ **/
+void EHRPWMConfigureAQActionOnA(unsigned int baseAddr,
+                                unsigned int zero,
+                                unsigned int period,
+                                unsigned int CAUp,
+                                unsigned int CADown,
+                                unsigned int CBUp,
+                                unsigned int CBDown,
+                                unsigned int SWForced)
+{
+    REG16(baseAddr + EHRPWM_AQCTLA) =
+        ((CBDown << EHRPWM_AQCTLA_CBD_SHIFT) & EHRPWM_AQCTLA_CBD) |
+        ((CBUp << EHRPWM_AQCTLA_CBU_SHIFT) & EHRPWM_AQCTLA_CBU) |
+        ((CADown << EHRPWM_AQCTLA_CAD_SHIFT) & EHRPWM_AQCTLA_CAD) |
+        ((CAUp << EHRPWM_AQCTLA_CAU_SHIFT) & EHRPWM_AQCTLA_CAU) |
+        ((period << EHRPWM_AQCTLA_PRD_SHIFT) & EHRPWM_AQCTLA_PRD) |
+        ((zero << EHRPWM_AQCTLA_ZRO_SHIFT) & EHRPWM_AQCTLA_ZRO);
+
+
+    REG16(baseAddr + EHRPWM_AQSFRC) = (REG16(baseAddr + EHRPWM_AQSFRC) &
+            (~EHRPWM_AQSFRC_ACTSFA)) | ((SWForced <<
+            EHRPWM_AQSFRC_ACTSFA_SHIFT) & EHRPWM_AQSFRC_ACTSFA);
+}
+
+
+/**
  * \brief   This API selects output mode. This allows to selectively enable or
  *          bypass the dead-band generation for the falling-edge and rising-edge
  *          delay.
@@ -530,3 +662,125 @@ void EHRPWMHRDisable(unsigned int baseAddr)
      REG16(baseAddr + EHRPWM_HRCNFG) &= (~EHRPWM_HR_EDGEMODE);
 }
 
+/**
+ * \brief   This API enables the particular PWM module.
+ *
+ * \param   baseAddr    Base Address of the PWM Module Registers.
+ *
+ * \return  None
+ *
+ **/
+void ehrPWM_Enable(unsigned int baseAddr)
+{
+	REG16(baseAddr + EHRPWM_AQCTLA) = 0x2 | (0x3 << 4);
+        REG16(baseAddr + EHRPWM_AQCTLB) = 0x2 | (0x3 << 8);
+	REG16(baseAddr + EHRPWM_TBCNT) = 0;
+	REG16(baseAddr + EHRPWM_TBCTL) = ~0x3;
+}
+
+/**
+ * \brief   This API disables the HR sub-module.
+ *
+ * \param   baseAddr    Base Address of the PWM Module Registers.
+ *
+ * \return  None
+ *
+ **/
+
+void ehrPWM_Disable(unsigned int baseAddr)
+{
+
+	REG16(baseAddr + EHRPWM_TBCTL) = 0x3;
+	REG16(baseAddr + EHRPWM_AQCTLA) = 0x1 | ( 0x3 << 4 );
+	REG16(baseAddr + EHRPWM_AQCTLB) = 0x1 | ( 0x3 << 8 );
+	REG16(baseAddr + EHRPWM_TBCNT)  = 0;
+}
+
+/* PWMSS setting
+ *      set pulse argument of epwm module
+ *
+ *      @param PWMID    : EPWMSS number , 0~2
+ *      @param HZ       : pulse HZ
+ *      @param dutyA    : Duty Cycle in ePWM A
+ *      @param dutyB    : Duty Cycle in ePWM B
+ *
+ *      @return         : 1 for success , 0 for failed
+ *
+ *      @example        :  PWMSS_Setting(0 , 50.0f , 50.0f , 25.0f);      // Generate 50HZ pwm in PWM0 ,
+ *                                                                              // duty cycle is 50% for ePWM0A , 25% for ePWM0B
+ *
+ *      @Note :
+ *              find an number nearst 65535 for TBPRD , to improve duty precision,
+ *
+ *              Using big TBPRD can increase the range of CMPA and CMPB ,
+ *              and it means we can get better precision on duty cycle.
+ *
+ *              EX : 20.25% duty cycle
+ *                  on TBPRD = 62500 , CMPA = 12656.25 ( .25 rejection) , real duty : 20.2496% (12656 /62500)
+ *                  on TBPRD = 6250  , CMPA = 1265.625 ( .625 rejection), real duty : 20.24%   (1265 6250)
+ *                  on TBPRD = 500   , CMPA = 101.25   ( .25 rejection) , real duty : 20.2%    (101/500)
+ *
+ *              Divisor = CLKDIV * HSPCLKDIV
+ *                      1 TBPRD : 10 ns (default)
+ *                      65535 TBPRD : 655350 ns
+ *                      65535 TBPRD : 655350 * Divisor ns  = X TBPRD : Cyclens
+ *
+ *              accrooding to that , we must find a Divisor value , let X nearest 65535 .
+ *              so , Divisor must  Nearest Cyclens/655350
+*/
+
+int PWMSS_Setting(unsigned int baseAddr, float HZ, float dutyA, float dutyB)
+{
+	int param_error =1;
+	if(HZ < 0)
+	param_error =0;
+	if(dutyA < 0.0f || dutyA > 100.0f || dutyB < 0.0f || dutyB > 100.0f)
+	param_error = 0;
+	if(param_error == 0) {
+	printf("ERROR in parameter \n");
+	}
+	dutyA /= 100.0f;
+	dutyB /= 100.0f;
+
+	/*Compute necessary TBPRD*/
+	float Cyclens = 0.0f;
+	float Divisor =0;
+	int i,j;
+	const float CLKDIV_div[] = {1.0,2.0,4.0,8.0,16.0,32.0,64.0,128.0};
+	const float HSPCLKDIV_div[] = {1.0, 2.0, 4.0, 6.0, 8.0, 10.0,12.0, 14.0};
+	int NearCLKDIV =7;
+	int NearHSPCLKDIV =7;
+	int NearTBPRD =0;
+
+	Cyclens = 1000000000.0f / HZ; /** 10^9 /Hz compute time per cycle (ns)
+				       */
+	Divisor = (Cyclens / 655350.0f);  /** am335x provide (128* 14) divider,
+                                           *  and per TBPRD means 10ns when divider 
+					   *  and max TBPRD is 65535 so max cycle 
+					   *  is 128 * 8 * 14 * 65535 * 10ns
+					   */
+	if(Divisor > (128 * 14)) {
+	printf("Can't generate %f HZ",HZ);
+	return 0;
+	}
+	else {
+		for (i=0;i<8;i++) {
+			for(j=0 ; j<8; j++) {
+				if((CLKDIV_div[i] * HSPCLKDIV_div[j]) < (CLKDIV_div[NearCLKDIV] 
+					* HSPCLKDIV_div[NearHSPCLKDIV]) && (CLKDIV_div[i] * HSPCLKDIV_div[j] > Divisor)) {
+						NearCLKDIV = i;
+						NearHSPCLKDIV = j;
+					}
+				}
+			}
+	NearTBPRD = (Cyclens / (10.0 * CLKDIV_div[NearCLKDIV] * HSPCLKDIV_div[NearHSPCLKDIV]));
+	/*setting clock divider and freeze time base*/
+	REG16(baseAddr + EHRPWM_TBCTL) = EHRPWM_TBCTL_CTRMODE_STOPFREEZE | (NearCLKDIV << 10) | (NearHSPCLKDIV << 7);
+	REG16(baseAddr + EHRPWM_CMPB) = (unsigned short)((float)NearTBPRD * dutyB);
+	REG16(baseAddr + EHRPWM_CMPA) = (unsigned short)((float)NearTBPRD * dutyA);
+	REG16(baseAddr + EHRPWM_TBPRD) = (unsigned short)NearTBPRD;
+	REG16(baseAddr + EHRPWM_TBCNT) = 0; 
+	}
+return 1;
+}
+
diff --git a/c/src/lib/libbsp/shared/include/gpio.h b/c/src/lib/libbsp/shared/include/gpio.h
index 7d8f67b..89606c8 100644
--- a/c/src/lib/libbsp/shared/include/gpio.h
+++ b/c/src/lib/libbsp/shared/include/gpio.h
@@ -947,6 +947,57 @@ extern rtems_status_code rtems_gpio_bsp_disable_interrupt(
 
 /** @} */
 
+extern void PWMSSTBClkEnable(unsigned int instance);
+extern void EHRPWMClockEnable(unsigned int baseAdd);
+extern void PWMSSModuleClkConfig(unsigned int instanceNum);
+extern void EHRPWMTimebaseClkConfig(unsigned int baseAddr,
+                             unsigned int tbClk,
+                             unsigned int moduleClk);
+extern void EHRPWMPWMOpFreqSet(unsigned int baseAddr,
+                        unsigned int tbClk,
+                        unsigned int pwmFreq,
+                        unsigned int counterDir,
+                        bool enableShadowWrite);
+extern void EHRPWMTimebaseSyncDisable(unsigned int baseAddr);
+extern void EHRPWMSyncOutModeSet(unsigned int baseAddr, unsigned int syncOutMode);
+extern void EHRPWMTBEmulationModeSet(unsigned int baseAddr, unsigned int mode);
+extern bool EHRPWMLoadCMPA(unsigned int baseAddr,
+                    unsigned int CMPAVal,
+                    bool enableShadowWrite,
+                    unsigned int ShadowToActiveLoadTrigger,
+                    bool OverwriteShadowFull);
+extern bool EHRPWMLoadCMPB(unsigned int baseAddr,
+                    unsigned int CMPBVal,
+                    bool enableShadowWrite,
+                    unsigned int ShadowToActiveLoadTrigger,
+                    bool OverwriteShadowFull);
+extern void EHRPWMConfigureAQActionOnB(unsigned int baseAddr,
+                                unsigned int zero,
+                                unsigned int period,
+                                unsigned int CAUp,
+                                unsigned int CADown,
+                                unsigned int CBUp,
+                                unsigned int CBDown,
+                                unsigned int SWForced);
+extern void EHRPWMConfigureAQActionOnA(unsigned int baseAddr,
+                                unsigned int zero,
+                                unsigned int period,
+                                unsigned int CAUp,
+                                unsigned int CADown,
+                                unsigned int CBUp,
+                                unsigned int CBDown,
+                                unsigned int SWForced);
+extern void EHRPWMDBOutput(unsigned int baseAddr, unsigned int DBgenOpMode);
+extern void EHRPWMChopperDisable(unsigned int baseAddr);
+extern void EHRPWMTZTripEventDisable(unsigned int baseAddr, bool osht_CBC);
+extern void EHRPWMETIntPrescale(unsigned int baseAddr, unsigned int prescale);
+extern void EHRPWMETIntSourceSelect(unsigned int baseAddr, unsigned int selectInt);
+extern void EHRPWMHRDisable(unsigned int baseAddr);
+extern void EPWMPinMuxSetup(void);
+extern int PWMSS_Setting(unsigned int baseAddr, float HZ, float dutyA, float dutyB);
+extern void ehrPWM_Disable(unsigned int baseAddr);
+extern void ehrPWM_Enable(unsigned int baseAddr);
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/c/src/lib/libcpu/arm/shared/include/am335x.h b/c/src/lib/libcpu/arm/shared/include/am335x.h
index 500e94c..3bcd33f 100644
--- a/c/src/lib/libcpu/arm/shared/include/am335x.h
+++ b/c/src/lib/libcpu/arm/shared/include/am335x.h
@@ -513,9 +513,7 @@
 #define SOC_EPWM_0_REGS                     (SOC_PWMSS0_REGS + SOC_EPWM_REGS)
 #define SOC_EPWM_1_REGS                     (SOC_PWMSS1_REGS + SOC_EPWM_REGS)
 #define SOC_EPWM_2_REGS                     (SOC_PWMSS2_REGS + SOC_EPWM_REGS)
-#define SOC_EPWM_MODULE_FREQ                 100 
  
-#define SOC_CONTROL_REGS                     (0x44E10000)
 #define CONTROL_PWMSS_CTRL   (0x664)
 #define CONTROL_PWMSS_CTRL_PWMSS0_TBCLKEN   (0x00000001u)
 #define CONTROL_PWMSS_CTRL_PWMMS1_TBCLKEN   (0x00000002u)
@@ -1323,4 +1321,7 @@
 #define CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_SW_SLEEP   (0x1u)
 #define CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP   (0x2u)
 
+#define CONTROL_CONF_GPMC_AD(n)   (0x800 + (n * 4))
+#define CONTROL_CONF_LCD_DATA(n)   (0x8a0 + (n * 4))
+#define EHRPWM_TBCNT	0x8
 
diff --git a/testsuites/samples/Makefile.am b/testsuites/samples/Makefile.am
index 374617b..70ebe57 100644
--- a/testsuites/samples/Makefile.am
+++ b/testsuites/samples/Makefile.am
@@ -1,6 +1,6 @@
 ACLOCAL_AMFLAGS = -I ../aclocal
 
-_SUBDIRS = hello capture ticker base_sp unlimited minimum fileio
+_SUBDIRS = hello capture ticker base_sp unlimited minimum fileio pwm
 
 if MPTESTS
 ## base_mp is a sample multiprocessing test
diff --git a/testsuites/samples/configure.ac b/testsuites/samples/configure.ac
index 91a3661..72a64a0 100644
--- a/testsuites/samples/configure.ac
+++ b/testsuites/samples/configure.ac
@@ -62,6 +62,7 @@ AC_CHECK_SIZEOF([time_t])
 AC_CONFIG_FILES([Makefile
 base_sp/Makefile
 hello/Makefile
+pwm/Makefile
 loopback/Makefile
 minimum/Makefile
 fileio/Makefile


diff --git a/testsuites/samples/pwm/Makefile.am b/testsuites/samples/pwm/Makefile.am
new file mode 100644
index 0000000..85d0fc1
--- /dev/null
+++ b/testsuites/samples/pwm/Makefile.am
@@ -0,0 +1,19 @@
+rtems_tests_PROGRAMS = pwm
+pwm_SOURCES = init.c
+
+dist_rtems_tests_DATA = pwm.scn
+dist_rtems_tests_DATA += pwm.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+
+LINK_OBJS = $(pwm_OBJECTS)
+LINK_LIBS = $(pwm_LDLIBS)
+
+hello$(EXEEXT): $(pwm_OBJECTS) $(pwm_DEPENDENCIES)
+	@rm -f pwm$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff --git a/testsuites/samples/pwm/init.c b/testsuites/samples/pwm/init.c
new file mode 100644
index 0000000..30fc6ae
--- /dev/null
+++ b/testsuites/samples/pwm/init.c
@@ -0,0 +1,77 @@
+/*
+This application enables EHRPWM2A, EHRPWM2B module. I am trying to generate pwm of 100KHz. 
+CMPB counter value loaded 100. At counter Pulse stay high, and when counter equals to 100 then pulse forced to low. 
+
+*/
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include<rtems/test.h>
+#include<bsp.h>
+#include<bsp/gpio.h>
+#include<stdio.h>
+#include<stdlib.h>
+#include<bsp/bbb-pwm.h>
+
+const char rtems_test_name[] = "Punit PWM test GSOC 2016";
+static void inline delay_sec(int sec)
+{
+  rtems_task_wake_after(sec*rtems_clock_get_ticks_per_second());
+}  
+
+rtems_task Init(rtems_task_argument argument);
+
+rtems_task Init(
+	rtems_task_argument ignored
+)
+{
+	rtems_test_begin();
+	printf("Starting PWM Testing");
+
+/* Initialization PWM API*/
+rtems_gpio_initialize();
+PWMSSModuleClkConfig(2);
+EPWMPinMuxSetup();
+EHRPWMClockEnable(SOC_PWMSS2_REGS);
+
+PWMSSTBClkEnable(2);
+
+
+
+        const float PWM_HZ = 100.0f ;   /* 100 Hz */
+        const float duty_A = 20.0f ;    /* 20% Duty cycle for PWM 0_A output */
+        const float duty_B = 50.0f ;    /* 50% Duty cycle for PWM 0_B output*/
+
+        printf("PWM Demo setting ....\n");
+        PWMSS_Setting(SOC_EPWM_2_REGS, PWM_HZ ,duty_A , duty_B);
+
+        printf("PWM  enable for 10s ....\n");
+        ehrPWM_Enable(SOC_EPWM_2_REGS);
+        delay_sec(10);
+
+        ehrPWM_Disable(SOC_EPWM_2_REGS);
+        printf("close\n");
+
+}
+
+/* NOTICE: the clock driver is enabled */
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+
+#define CONFIGURE_MAXIMUM_TASKS            1
+#define CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM
+
+#define CONFIGURE_MAXIMUM_SEMAPHORES    1
+
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE 
+
+#define CONFIGURE_EXTRA_TASK_STACKS         (2 * RTEMS_MINIMUM_STACK_SIZE)
+
+#define CONFIGURE_INITIAL_EXTENSIONS RTEMS_TEST_INITIAL_EXTENSION
+
+#define CONFIGURE_INIT
+#include <rtems/confdefs.h>
+
diff --git a/testsuites/samples/pwm/pwm.doc b/testsuites/samples/pwm/pwm.doc
new file mode 100644
index 0000000..9812864
--- /dev/null
+++ b/testsuites/samples/pwm/pwm.doc
@@ -0,0 +1,9 @@
+#  COPYRIGHT (c) 1989-1999.
+#  On-Line Applications Research Corporation (OAR).
+#
+#  The license and distribution terms for this file may be
+#  found in the file LICENSE in this distribution or at
+#  http://www.rtems.org/license/LICENSE.
+#
+
+
diff --git a/testsuites/samples/pwm/pwm.scn b/testsuites/samples/pwm/pwm.scn
new file mode 100644
index 0000000..057ab6e
--- /dev/null
+++ b/testsuites/samples/pwm/pwm.scn
@@ -0,0 +1,3 @@
+*** GPIO TEST ***
+Gpio Testing
+*** END OF GPIO TEST ***
-- 
2.7.1

